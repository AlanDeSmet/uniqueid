#! /usr/bin/perl -wT

# Unique ID
#
# Experimental implementation for algorithms as described on the Unique ID web
# site (http://www.highprogrammer.com/alan/numbers/)
#
# This program is intended to be run as a CGI (Common Gateway Interface)
# running under a web server like Apache (http://www.apache.org).  You can find
# further information about CGIs here http://hoohoo.ncsa.uiuc.edu/cgi/ You will
# want to consult the documentation for your web server for details on how to
# install a CGI.  This program requires Perl (http://www.perl.org/) and the
# Perl modules CGI (http://search.cpan.org/search?dist=CGI.pm) and
# Text::Soundex (http://search.cpan.org/search?dist=Text-Soundex).
#
# The author is not able to help with installation of a web server, perl, perl
# modules, or CGI programs.
#
# Copyright 2002, Alan De Smet http://www.highprogrammer.com/alan/email.html
#
# This file is part of UniqueID.
#
# UniqueID is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA
#
# A copy of the GNU General Public License should have been distributed with
# this file.  You should be able to find it in the file named COPYING.txt


use CGI qw(param);
use Text::Soundex;
use strict;

my $PROGRAM_NAME = 'Unique ID';
my $VERSION = '0.2.0';

#===============================================================================
my(%DLFMR_FIRST_MALE) = (
	20=>['Albert'], 40=>['Arthur'], 80=>['Bernard'], 120=>['Carl'],
	140=>['Charles'], 180=>['Donald'], 220=>['Edward'], 260=>['Frank'],
	300=>['George'], 340=>['Harold'], 360=>['Harry'], 380=>['Henry'],
	440=>['James'], 460=>['John'], 480=>['Joseph'], 560=>['Martin'],
	580=>['Marvin'], 600=>['Melvin'], 680=>['Paul'], 740=>['Richard'],
	760=>['Robert'], 820=>['Thomas'], 900=>['Walter'], 920=>['William'],
	);
my(%DLFMR_FIRST_FEMALE) = (
	20=>['Alice'], 40=>['Ann', 'Anna', 'Anne', 'Annie'],
	80=>['Bette', 'Bettie', 'Betty'], 120=>['Catherine'],
	140=>['Clara'], 180=>['Dorothy'], 220=>['Elizabeth'],
	260=>['Florence'], 300=>['Grace'], 340=>['Harriet'],
	360=>['Hazel'], 380=>['Helen'], 440=>['Jane', 'Jayne'],
	460=>['Jean'], 480=>['Joan'], 580=>['Mary'], 600=>['Mildred'],
	680=>['Patricia'], 740=>['Ruby'], 760=>['Ruth'], 820=>['Thelma'],
	900=>['Wanda'], 920=>['Wilma'],
	);
my(%DLFMR_FIRST_INIT) = (
	0 => 'A', 60 => 'B', 100 => 'C', 160 => 'D', 200 => 'E', 240 => 'F',
	280 => 'G', 320 => 'H', 400 => 'I', 420 => 'J', 500 => 'K', 520 => 'L',
	540 => 'M', 620 => 'N', 640 => 'O', 660 => 'P', 700 => 'Q', 720 => 'R',
	780 => 'S', 800 => 'T', 840 => 'U', 860 => 'V', 880 => 'W', 940 => 'X',
	960 => 'Y', 980 => 'Z',
	);
my(%DLFMR_MIDDLE_INIT) = (
	1 => [qw(A)], 2 => [qw(B)], 3 => [qw(C)], 4 => [qw(D)],
	5 => [qw(E)], 6 => [qw(F)], 7 => [qw(G)], 8 => [qw(H)],
	9 => [qw(I)], 10 => [qw(J)], 11 => [qw(K)], 12 => [qw(L)],
	13 => [qw(M)], 14 => [qw(N O)], 15 => [qw(P Q)], 16 => [qw(R)],
	17 => [qw(S)], 18 => [qw(T U V)], 19 => [qw(W X Y Z)],
	);

my(%DLFM_FIRST_MALE) = uc_hash_keys(reverse_plural_hash(%DLFMR_FIRST_MALE));
my(%DLFM_FIRST_FEMALE) = uc_hash_keys(reverse_plural_hash(%DLFMR_FIRST_FEMALE));
my(%DLFM_FIRST_INIT) = uc_hash_keys(reverse_hash(%DLFMR_FIRST_INIT));
my(%DLFM_MIDDLE_INIT) = uc_hash_keys(reverse_plural_hash(%DLFMR_MIDDLE_INIT));

#===============================================================================
sub uc_hash_keys {
	my(%hash) = @_;
	my %result;
	foreach my $key (keys %hash) {
		$result{uc($key)} = $hash{$key}
	}
	return %result;
}

#===============================================================================
sub reverse_plural_hash {
	my(%hash) = @_;
	my %result;
	foreach my $key (keys %hash) {
		foreach my $value (@{$hash{$key}}) {
			$result{$value} = $key;
		}
	}
	return %result;
}

#===============================================================================
sub reverse_hash {
	my(%hash) = @_;
	my %result;
	foreach my $key (keys %hash) {
		$result{$hash{$key}} = $key;
	}
	return %result;
}

#===============================================================================
sub english_list_join {
	my($word, @list) = @_;
	if(scalar @list == 0) {
		return '';
	}
	if(scalar @list == 1) {
		return $list[0];
	}
	if(scalar @list == 2) {
		return "$list[0] $word $list[1]";
	}
	my $tail = pop @list;
	return (join ', ', @list).", $word $tail";
}

#===============================================================================
sub dlfirstmiddle_middle_from_code {
	my($code) = @_;
	$code %= 20;
	if(not exists $DLFMR_MIDDLE_INIT{$code}) {
		return '';
	}

	my(@answer) = @{$DLFMR_MIDDLE_INIT{$code}};

	return english_list_join('or', @answer);
}

#===============================================================================
sub dlfirstmiddle_first_from_code {
	my($code, $gender) = @_;
	$code -= $code % 20;
	my(@female, @male);
	if(exists $DLFMR_FIRST_FEMALE{$code}) {
		@female = @{$DLFMR_FIRST_FEMALE{$code}};
	}
	if(exists $DLFMR_FIRST_MALE{$code}) {
		@male = @{$DLFMR_FIRST_MALE{$code}};
	}

	my(@probable, @improbable);
	if($gender =~ /^m/i) {
		@probable = @male;
		@improbable = @female;
	} elsif($gender =~ /^f/i) {
		@probable = @female;
		@improbable = @male;
	} else {
		@probable = (@male, @female);
	}

	if(not @probable and exists $DLFMR_FIRST_INIT{$code}) {
		@probable = ($DLFMR_FIRST_INIT{$code}.'.');
	}

	my $return = english_list_join('or', @probable);
	if(scalar @improbable) {
		$return .= ' (or possibly '.
			english_list_join('or', @improbable).')';
	}
	return $return;
}

#===============================================================================
sub dlfirstmiddle_encode {
	my($FN, $MiddleInit) = @_;
	my($NameNum) = 0;

	$FN = uc($FN);
	$MiddleInit = uc($MiddleInit);
	my($first_init)= ($FN =~ /^(.)/);

	if(exists $DLFM_FIRST_MALE{$FN}) {
		$NameNum = $DLFM_FIRST_MALE{$FN};
	} elsif(exists $DLFM_FIRST_FEMALE{$FN}) {
		$NameNum = $DLFM_FIRST_FEMALE{$FN};
	} elsif(exists $DLFM_FIRST_INIT{$first_init}) {
		$NameNum = $DLFM_FIRST_INIT{$first_init};
	} else {
		return 'BAD';
	}

	if(defined($DLFM_MIDDLE_INIT{$MiddleInit}))
		{ $NameNum += $DLFM_MIDDLE_INIT{$MiddleInit}; }
	else
		{ return('BAD'); }

	return sprintf("%03d",$NameNum);
}

#===============================================================================
sub soundex_database { '/home/chaos/public/soundex.data' }


#===============================================================================
sub soundex_similar_last_names
{
	my($Soundex) = @_;
	my($database) = main::soundex_database();
	open(INDEX,$database) or
		return "Name database is currently unavailable.  ".
		"Unable to display name guesses. Please try again later.".
		"($database  $!)"
		;
	main::look(*INDEX, $Soundex, 0, 0);
	my $line = <INDEX>;
	close(INDEX);
	($line) = ($line =~ /.+\t(.+)/);
	my(@names) = split(/, ?/, $line);
	foreach my $n (@names) {
		$n =~ s/(\w+)/\u\L$1/g;
	}
	return @names;
}

#===============================================================================
sub soundex_sound_guess
{
	my($Name) = @_;
	my($Return, @Parts, $This);
	@Parts = split(//,$Name);
	$Return = shift(@Parts).'e';
	while($This = shift(@Parts))
	{
		if   ($This == 1) { $Return .= 'be'; } #bfpv
		elsif($This == 2) { $Return .= 'se'; } #cgjkqsxz
		elsif($This == 3) { $Return .= 'te'; } #td
		elsif($This == 4) { $Return .= 'le'; } #l
		elsif($This == 5) { $Return .= 'me'; } #mn
		elsif($This == 6) { $Return .= 're'; } #r
	}
	return($Return);
}

#===============================================================================
sub describe_soundex
{
	my($Name) = @_;
	my($Return, @Parts, $This);

	@Parts = split(//,$Name);

	$Return = 'Starts with a '.shift(@Parts);
	while($This = shift(@Parts))
	{
		$Return .= ', followed by a ';
		if   ($This == 1) { $Return .= 'labial (B, F, P, or V)'; }
		elsif($This == 2) { $Return .= 'gutteral or sibilant (C, G, J, K, Q, S, X, or Z)'; }
		elsif($This == 3) { $Return .= 'dental (D or T)'; }
		elsif($This == 4) { $Return .= 'long liquid (L)'; }
		elsif($This == 5) { $Return .= 'nasal (M or N)'; }
		elsif($This == 6) { $Return .= 'short liquid (R)'; }
	}
	$Return .= '.';
	return($Return);
}

#===============================================================================
sub validate_options
{
	my($params, $options) = @_;
	my(%params) = %{$params};
	my(@options) = @{$options};
	my($error, %error) = ('');
	foreach my $option (@options) {
		my($name, $key) = @{$option};
		next if not defined $key or not length $key;
		my($value) = $params{$key};
		if(not defined $value or not length $value) {
			if(not defined $error{$key}) {
				$error{$key} = '';
			}
			$error{$key} .= "Please specify $name. ";
		}
	}
	return ($error, %error);
}

#===============================================================================
sub path_to_script {
	return $ENV{'SCRIPT_NAME'} || '';
}

#===============================================================================
sub format_label {
	my($label) = @_;
	my($indent) = ($label =~ /^( *)/);
	$indent =~ s/ /\&nbsp;\&nbsp;\&nbsp;/g;
	$label =~ s/^ */$indent/g;
	return qq(<STRONG>$label:\&nbsp;</STRONG>);
}

#===============================================================================
sub format_key_value {
	my($key, $value) = @_;
	return format_label($key).$value."<BR>\n";
}

#===============================================================================
# Usage: &look(*FILEHANDLE,$key,$dict,$fold)
# Sets file position in FILEHANDLE to be first line greater than or equal
# (stringwise) to $key.  Pass flags for dictionary order and case folding.
# taken from look.pl, part of perl distribution.

sub look {
	local(*FH, $_);
	my($key, $dict, $fold);
	(*FH,$key,$dict,$fold) = @_;
	my($max,$min,$mid);
	my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
	   $blksize,$blocks) = stat(FH);
	$min = 0;
	$blksize = 8192 unless $blksize;
	$key =~ s/[^\w\s]//g if $dict;
	$key = lc $key if $fold;
	$max = int($size / $blksize);
	while ($max - $min > 1) {
		$mid = int(($max + $min) / 2);
		seek(FH,$mid * $blksize,0);
		$_ = <FH> if $mid;		# probably a partial line
		$_ = <FH>;
		chop;
		s/[^\w\s]//g if $dict;
		$_ = lc $_ if $fold;
		if ($_ lt $key) {
			$min = $mid;
		}
		else {
			$max = $mid;
		}
	}
	$min *= $blksize;
	seek(FH,$min,0);
	<FH> if $min;
	while (<FH>) {
		chop;
		s/[^\w\s]//g if $dict;
		$_ = lc $_ if $fold;
		last if $_ ge $key;
		$min = tell(FH);
	}
	seek(FH,$min,0);
	$min;
}





################################################################################
################################################################################
################################################################################
################################################################################



package UniqueID::Coding::DLFirstMiddle;



sub new {
	my $class = shift;
	$class = ref($class) if ref($class);

	bless my $self = {}, $class;

	return $self;
}

sub uid { 'c_firstmiddler' }
sub display_name { "First Name Middle Initial Coding Analyzer" }
sub describe {
	my($link) = main::path_to_script();
	return <<_EODESC;
Decode
<a href="http://www.highprogrammer.com/alan/numbers/dlfirstmiddle.html">name
encoding</a> used by many states for driver's licenses.
_EODESC
#'
}

sub options
{
	return(
		['Code', 'w', 'text', 3],
	);
}

sub process
{
	my($self) = shift;
	my(%params) = @_;
	my($code) = $params{'w'};
	my(%error_fields, $error_explain, $output);
	
	if(not defined $code or not length $code) {
		$error_fields{'w'} .= "Please specify an encoded name.";
	}

	if((defined $error_explain and length $error_explain) or
		scalar keys %error_fields){
		return(\%error_fields, $error_explain, $output);
	}

	my $middle_init = main::dlfirstmiddle_middle_from_code($code);
	my $first_name = main::dlfirstmiddle_first_from_code($code);

	$output = 
		main::format_key_value('First Name', $first_name).
		main::format_key_value('Middle Initial', $middle_init);

	return(\%error_fields, $error_explain, $output);
}






################################################################################
################################################################################
################################################################################
################################################################################



package UniqueID::Coding::Soundex;


sub new {
	my $class = shift;
	$class = ref($class) if ref($class);

	bless my $self = {}, $class;

	return $self;
}

sub uid { 'c_soundex' }
sub display_name { "Soundex Coding" }
sub describe {
	my($link) = main::path_to_script();
	return <<_EODESC;
Given an english word, determine the
<A HREF="http://www.highprogrammer.com/alan/numbers/soundex.html">soundex
code</A>.  Soundex codes are used in many places, including
<A HREF="http://www.highprogrammer.com/alan/numbers/dl_wi/">Wisconsin Driver's
License Numbers</A>.
_EODESC
#'
}

sub options
{
	return(
		["Word", 'w', 'text', 50],
	);
}

sub process
{
	my($self) = shift;
	my(%params) = @_;
	my($word) = $params{'w'};
	my(%error_fields, $error_explain, $output);
	
	if(not defined $word or not length $word) {
		$error_fields{'w'} .= "Please specify an english word.";
	}

	if((defined $error_explain and length $error_explain) or
		scalar keys %error_fields){
		return(\%error_fields, $error_explain, $output);
	}

	my $soundex = main::soundex($word);

	$output = main::format_key_value('Soundex', $soundex);

	return(\%error_fields, $error_explain, $output);
}


################################################################################
################################################################################
################################################################################
################################################################################


package UniqueID::DriversLicense::USShared;

sub uid {
	my $self = shift;
	my $short = $self->state_short();
	return "dl_".$short;
}
sub display_name {
	my $self = shift;
	my $long = $self->state_long();
	return "Driver's License Calculator: $long"
}
sub describe_more { "" }

sub describe {
	my $self = shift;
	my($link) = main::path_to_script();
	my $state = $self->state_long();
	my $state_short = $self->state_short();
	my $state_short_r = $state_short.'r';
	my $describe_more = $self->describe_more();
	return <<_EODESC;
Calculate your $state Driver's License number from your
information.
<A HREF="http://www.highprogrammer.com/alan/numbers/dl_us_shared.html">How it works</A>.
<A HREF="$link/dl_$state_short_r">Reverse analyze an existing number</A>.
$describe_more
_EODESC
}

sub options
{
	my($self) = shift;
	my @options;
	push @options, ['Last Name', 'last', 'text', 40]
		if $self->need_last_name();
	push @options, ['First Name', 'first', 'text', 40]
		if $self->need_first_name();
	push @options, ['Middle Initial', 'middle', 'text', 1]
		if $self->need_middle_initial();
	push @options, ['Gender', 'gender', 'radio', ['M', 'F'] ]
		if $self->need_gender();
	push @options, ['Date of Birth']
		if $self->need_dob_year() or $self->need_dob_month() or $self->need_dob_day() ;
	push @options, [' Year', 'y', 'text', 4]
		if $self->need_dob_year();
	push @options, [' Month', 'm', 'text', 2]
		if $self->need_dob_month();
	push @options, [' Day', 'd', 'text', 2]
		if $self->need_dob_day();
	return @options;
}

sub need_last_name { return 1; }
sub need_first_name { return 1; }
sub need_middle_initial { return 1; }
sub need_gender { return 1; }
sub need_dob_year { return 1; }
sub need_dob_month { return 1; }
sub need_dob_day { return 1; }

sub trim_edge_whitespace {
	my($in) = @_;
	if(not defined $in) {
		return undef;
	}
	$in =~ s/^\s*//;
	$in =~ s/\s*$//;
	return $in;
}

sub process
{
	my($self) = shift;
	my(%params) = @_;
	my($last) = $params{'last'};
	my($first) = $params{'first'};
	my($middle) = $params{'middle'};
	my($gender) = uc($params{'gender'});
	my($yy) = $params{'y'};
	my($mm) = $params{'m'};
	my($dd) = $params{'d'};
	my(%error_fields, $error_explain, $output);

	($error_explain, %error_fields) =
		main::validate_options(\%params, [$self->options()]);

	$last = trim_edge_whitespace($last);
	$middle = trim_edge_whitespace($middle);
	$first = trim_edge_whitespace($first);

	if($self->need_dob_year()) {
		$yy -= 1900 if $yy >= 1900 and $yy < 2000;
		$yy -= 2000 if $yy >= 2000 and $yy < 2100;

		if($yy > 99 or $yy < 0) {
			$error_fields{'y'} .= 'Please specify year of birth as a one or '.
				'two digit number. '.
				'For example, for 1975 specify "75", for 2006 specify "6".';
		}
	}

	if($self->need_dob_month()) {
		if($mm > 12 or $mm < 1) {
			$error_fields{'m'} .= 'Please specify month of birth as a '.
				'number from 1 to 12. '.
				'For example, for January specify "1", for December specify "12".';
		}
	}

	if($self->need_dob_day()) {
		if($dd > 31 or $dd < 1) {
			$error_fields{'d'} .= 'Please specify day of birth as a '.
				'number from 1 to 31.';
		}
	}

	if($self->need_gender()) {
		if($gender ne 'M' and $gender ne 'F') {
			$error_fields{'gender'} .= 'Please specify gender (M or F)';
		}
	}
	
	if((defined $error_explain and length $error_explain) or
		scalar keys %error_fields){
		return(\%error_fields, $error_explain, $output);
	}

	my $dl = $self->encode_drivers_license
		($last, $first, $middle, $gender, $yy, $mm, $dd);

	$output = main::format_key_value("Driver's License Number", $dl).
		$self->result_notes();

	return(\%error_fields, $error_explain, $output);
}

sub encode_drivers_license {
	my $self = shift;
	my($last, $first, $middle, $gender, $yy, $mm, $dd) = @_;
	$middle = substr $middle, 0, 1;
	my($YearTens, $YearOnes) = split(//,sprintf("%02d",$yy));
	my $dl = $self->format_license(
		main::soundex($last),
		dlfirstmiddle_encode($first, $middle),
		$YearTens, $YearOnes,
		$self->month_day_gender($mm, $dd, $gender));
	return $dl;
}

sub month_day_gender
{
	my $self = shift;
	my($Month, $Day, $Gender) = @_;
	my($DateNo);
	$Gender = uc($Gender);

	$DateNo = ($Month - 1) * $self->month_mult() + $Day;
	if($Gender eq 'F') { $DateNo += $self->female_add(); }

	$DateNo = sprintf("%03d",$DateNo);

	return($DateNo);
}


sub dlfirstmiddle_encode
{
	my($FN, $MiddleInit) = @_;
	return main::dlfirstmiddle_encode($FN, $MiddleInit);
}







################################################################################
################################################################################
################################################################################
################################################################################


package UniqueID::DriversLicense::USSharedReverse;



sub new {
	my $class = shift;
	$class = ref($class) if ref($class);

	bless my $self = {}, $class;

	return $self;
}


sub uid {
	my $self = shift;
	my $short = $self->state_short();
	return "dl_".$short."r";
}
sub display_name {
	my $self = shift;
	my $long = $self->state_long();
	return "Driver's License Analyzer: $long"
}

sub options
{
	my $self = shift;
	my $long = $self->state_long();
	return(
		["$long Driver's License Number", 'l', 'text', 17],
	);
}

sub process
{
	my($self) = shift;
	my(%params) = @_;
	my($lic) = $params{'l'};
	my(%error_fields, $error_explain, $output);

	my $state_name = $self->state_long();
	my $number_re = $self->number_regex();
	my $number_sample = $self->number_sample();
	

	my($last, $first_middle, $year_ten, $year_one, $day_month, $count) =
		($lic =~ /$number_re/);
	if(not defined $day_month) {
		$error_fields{'l'} .=
		"Please specify a $state_name Driver's License number. It will look ".
		"like \"$number_sample\".";
	}

	if((defined $error_explain and length $error_explain) or
		scalar keys %error_fields){
		return(\%error_fields, $error_explain, $output);
	}

	my($gender) = $self->gender($day_month);
	my($first_name) = $self->first_name($first_middle, $gender);
	my($middle_init) = $self->middle_init($first_middle).'.';
	my($last_name_sound) = main::describe_soundex($last);
	my($last_name_sound_guess) = main::soundex_sound_guess($last);
	my(@similar_last_names) = main::soundex_similar_last_names($last);
	my($similar_last_names) = join(', ', @similar_last_names);
	my($month) = $self->month_name($day_month);
	my($day) = $self->day($day_month);
	my($year) = $year_ten.$year_one;

	$output =
		main::format_key_value('First Name', $first_name).
		main::format_key_value('Middle Initial', $middle_init).
		main::format_key_value('Last Name', $last_name_sound.
		" Perhaps it sounds like \"$last_name_sound_guess\"").
		main::format_key_value('Last Name Guesses', $similar_last_names).
		main::format_key_value('Gender', $gender).
		main::format_key_value('Date of Birth', "$month $day, '$year").
		main::format_key_value('Wild Guess', "$first_name $middle_init ".
			"$similar_last_names[0], $gender, born $month $day, 19$year").
		'';

	return(\%error_fields, $error_explain, $output);
}

sub day {
	my $self = shift;
	my($input) = @_;
	$input %= $self->female_add();
	return($input % $self->month_mult());
}

sub month_num {
	my $self = shift;
	my($input) = @_;
	$input %= $self->female_add();
	return(($input - $self->day($input)) / $self->month_mult() + 1);
}

sub month_name {
	my $self = shift;
	my($input) = @_;
	my(@MONTHS) = ( 'January', 'February', 'March', 'April', 'May', 'June',
		'July', 'August', 'September', 'October', 'November', 'December' );
	my $num = $self->month_num($input);
	if($num < 1 or $num > 12) {
		return "BADMONTH";
	}
	return @MONTHS[$self->month_num($input)-1];
}

sub gender {
	my $self = shift;
	my($input) = @_;
	if($input >= 500) { return 'female'; }
	return 'male';
}

sub middle_init
{
	my $self = shift;
	my($input) = @_;
	return main::dlfirstmiddle_middle_from_code($input);
}


sub first_name
{
	my $self = shift;
	my($Input, $Gender) = @_;
	return main::dlfirstmiddle_first_from_code($Input, $Gender);
}



################################################################################
################################################################################
################################################################################
################################################################################


package UniqueID::DriversLicense::Wisconsin;
@UniqueID::DriversLicense::Wisconsin::ISA = ( "UniqueID::DriversLicense::USShared" );


sub new {
	my $class = shift;
	$class = ref($class) if ref($class);

	bless my $self = {}, $class;

	return $self;
}

sub state_long { 'Wisconsin' }
sub state_short { 'wi' }
sub female_add { 500 }
sub month_mult { 40 }
sub format_license {
	my $self = shift;
	my($last_soundex, $first_middle_code,
		$year_tens, $year_ones, $month_day_gender_code) = @_;
	return $last_soundex.'-'.
		$first_middle_code. $year_tens.'-'.$year_ones.
		$month_day_gender_code.'-??';
}
sub result_notes {
	"The last two digits cannot be determined.  They represent the ".
	"number of people who have the exact same license number as you ".
	"(excepting the last two digits) when you got your license." }





################################################################################
################################################################################
################################################################################
################################################################################


package UniqueID::DriversLicense::WisconsinReverse;

@UniqueID::DriversLicense::WisconsinReverse::ISA = ( "UniqueID::DriversLicense::USSharedReverse" );

sub new {
	my $class = shift;
	$class = ref($class) if ref($class);

	bless my $self = {}, $class;

	return $self;
}

sub state_long { 'Wisconsin' }
sub state_short { 'wi' }
sub number_regex { q/([A-Za-z]\d\d\d)-(\d\d\d)(\d)-(\d)(\d\d\d)-(..)/ }
sub number_sample { "S530-4615-0244-03" }
sub female_add { 500 }
sub month_mult { 40 }
sub describe {
	my($link) = main::path_to_script();
	return <<_EODESC;
Given a Wisconsin Driver's License number, determine its owner's
identity.
<A HREF="http://www.highprogrammer.com/alan/numbers/dl_us_shared.html">How it works</A>.
<A HREF="$link/dl_wi">Create a fictional number to test</A>.
_EODESC
#'
}


















################################################################################
################################################################################
################################################################################
################################################################################


package UniqueID::DriversLicense::Illinois;
@UniqueID::DriversLicense::Illinois::ISA = ( "UniqueID::DriversLicense::USShared" );


sub new {
	my $class = shift;
	$class = ref($class) if ref($class);

	bless my $self = {}, $class;

	return $self;
}

sub state_long { 'Illinois' }
sub state_short { 'il' }
sub female_add { 600 }
sub month_mult { 31 }
sub format_license {
	my $self = shift;
	my($last_soundex, $first_middle_code,
		$year_tens, $year_ones, $month_day_gender_code) = @_;
	return $last_soundex.'-'.
		$first_middle_code. $year_tens.'-'.$year_ones.
		$month_day_gender_code;
}
sub result_notes { "" }
sub describe_more { "<strong>This is a work in progress and not yet complete.</strong>" }





################################################################################
################################################################################
################################################################################
################################################################################

package UniqueID::DriversLicense::IllinoisReverse;

@UniqueID::DriversLicense::IllinoisReverse::ISA = ( "UniqueID::DriversLicense::USSharedReverse" );

sub new {
	my $class = shift;
	$class = ref($class) if ref($class);

	bless my $self = {}, $class;

	return $self;
}

sub state_long { 'Illinois' }
sub state_short { 'il' }
sub number_regex { q/([A-Za-z]\d\d\d)-(\d\d\d)(\d)-(\d)(\d\d\d)/ }
sub number_sample { "S530-4615-0244" }
sub female_add { 600 }
sub month_mult { 31 }
sub describe {
	my($link) = main::path_to_script();
	return <<_EODESC;
Given an Illinois Driver's License number, determine its owner's
identity.
<STRONG>This is a work in progress and is not yet complete.</STRONG>
<A HREF="http://www.highprogrammer.com/alan/numbers/dl_us_shared.html">How it works</A>.
<A HREF="$link/dl_il">Create a fictional number to test</A>.
_EODESC
#'
}


################################################################################
################################################################################
################################################################################
################################################################################


package UniqueID::DriversLicense::Florida;
@UniqueID::DriversLicense::Florida::ISA = ( "UniqueID::DriversLicense::USShared" );


sub new {
	my $class = shift;
	$class = ref($class) if ref($class);

	bless my $self = {}, $class;

	return $self;
}

sub state_long { 'Florida' }
sub state_short { 'fl' }
sub female_add { 500 }
sub month_mult { 40 }
sub format_license {
	my $self = shift;
	my($last_soundex, $first_middle_code,
		$year_tens, $year_ones, $month_day_gender_code) = @_;
	return $last_soundex.'-'.
		$first_middle_code. '-'. $year_tens.$year_ones. '-'.
		$month_day_gender_code;
}
sub result_notes { "" }
sub describe_more { "<strong>This is a work in progress and not yet complete.</strong>" }




################################################################################
################################################################################
################################################################################
################################################################################

package UniqueID::DriversLicense::FloridaReverse;

@UniqueID::DriversLicense::FloridaReverse::ISA = ( "UniqueID::DriversLicense::USSharedReverse" );

sub new {
	my $class = shift;
	$class = ref($class) if ref($class);

	bless my $self = {}, $class;

	return $self;
}

sub state_long { 'Florida' }
sub state_short { 'fl' }
sub number_regex { q/([A-Za-z]\d\d\d)-(\d\d\d)-(\d)(\d)-(\d\d\d)/ }
sub number_sample { "S530-461-50-244" }
sub female_add { 500 }
sub month_mult { 40 }
sub describe {
	my($link) = main::path_to_script();
	return <<_EODESC;
Given a Florida Driver's License number, determine its owner's
identity.
<STRONG>This is a work in progress and is not yet complete.</STRONG>
<A HREF="http://www.highprogrammer.com/alan/numbers/dl_us_shared.html">How it works</A>.
<A HREF="$link/dl_fl">Create a fictional number to test</A>.
_EODESC
#'
}

################################################################################
################################################################################
################################################################################
################################################################################


package UniqueID::DriversLicense::Washington;
@UniqueID::DriversLicense::Washington::ISA = ( "UniqueID::DriversLicense::USShared" );


sub new {
	my $class = shift;
	$class = ref($class) if ref($class);

	bless my $self = {}, $class;

	return $self;
}

sub state_long { 'Washington' }
sub state_short { 'wa' }
sub result_notes { <<ENDIT

This is preliminary work.  Question marks indicate things that I don't yet
know.  I don't know how to handle last names shorter than 5 letters, and I know
nothing about the last three digits.
If you can offer any suggestions,
<a href=\"http://www.highprogrammer.com/alan/email.html\">please contact me</a>.
Also, given some last names, birthdays, and driver's license numbers, I can
probably figure out what it going on.
<a href=\"http://www.highprogrammer.com/alan/email.html\">Please contact me</a> if you're willing to help me in this way.

ENDIT
}
sub describe_more { <<ENDIT

<strong>This is preliminary work.
If you can offer any suggestions,
<a href=\"http://www.highprogrammer.com/alan/email.html\">please contact me</a>.
Also, given some last names, birthdays, and driver's license numbers, I can
probably figure out what it going on.
<a href=\"http://www.highprogrammer.com/alan/email.html\">Please contact me</a> if you're willing to help me in this way.
</strong>

ENDIT
}

sub need_last_name { return 1; }
sub need_first_name { return 1; }
sub need_middle_initial { return 1; }
sub need_gender { return 0; }
sub need_dob_year { return 1; }
sub need_dob_month { return 0; }
sub need_dob_day { return 0; }

sub toupper {
		return "\U@_";
}

sub encode_drivers_license {
	my $self = shift;
	my($last, $first, $middle, $gender, $yy, $mm, $dd) = @_;
	$last = toupper(substr $last."????", 0, 5);
	$middle = toupper(substr $middle, 0, 1);
	$first = toupper(substr $first, 0, 1);
	$yy = sprintf("%02d",$yy);
	return "$last$first$middle$yy???";
}

sub describe {
	my $self = shift;
	my($link) = main::path_to_script();
	my $state = $self->state_long();
	my $state_short = $self->state_short();
	my $state_short_r = $state_short.'r';
	my $describe_more = $self->describe_more();
#<A HREF="http://www.highprogrammer.com/alan/numbers/dl_us_shared.html">How it works</A>.
#<A HREF="$link/dl_$state_short_r">Reverse analyze an existing number</A>.
	return <<_EODESC;
Calculate your $state Driver's License number from your
information.
$describe_more
_EODESC
}




################################################################################
################################################################################
################################################################################
################################################################################


package UniqueID::DriversLicense::NewHampshire;
@UniqueID::DriversLicense::NewHampshire::ISA = ( "UniqueID::DriversLicense::USShared" );

# Thanks to "RGM" who sent me a description of New Hampshire's system.


sub new {
	my $class = shift;
	$class = ref($class) if ref($class);

	bless my $self = {}, $class;

	return $self;
}

sub state_long { 'New Hampshire' }
sub state_short { 'nh' }
sub result_notes { <<ENDIT

This is preliminary work.
<a href=\"http://www.highprogrammer.com/alan/email.html\">Let me know</a> if you find
problems.

The last digit cannot be determined.  It represents the
number of people who have the exact same license number as you
(excepting the last digit) when you got your license.

ENDIT
}
sub describe_more { <<ENDIT

<strong>This is preliminary work.</strong>

ENDIT
}

#sub need_last_name { return 1; }
#sub need_first_name { return 1; }
sub need_middle_initial { return 0; }
sub need_gender { return 0; }
#sub need_dob_year { return 1; }
#sub need_dob_month { return 1; }
#sub need_dob_day { return 1; }

sub toupper {
		return "\U@_";
}

sub encode_drivers_license {
	my $self = shift;
	my($last, $first, $middle, $gender, $yy, $mm, $dd) = @_;
	my $lastfirst = toupper(substr $last, 0, 1);
	my $lastlast = toupper(substr $last, -1);
	$first = toupper(substr $first, 0, 1);
	return sprintf("%02d%s%s%s%02d%02d?",
		$mm, $lastfirst, $lastlast, $first, $yy, $dd);
}

sub describe {
	my $self = shift;
	my($link) = main::path_to_script();
	my $state = $self->state_long();
	my $state_short = $self->state_short();
	my $state_short_r = $state_short.'r';
	my $describe_more = $self->describe_more();
#<A HREF="http://www.highprogrammer.com/alan/numbers/dl_us_shared.html">How it works</A>.
#<A HREF="$link/dl_$state_short_r">Reverse analyze an existing number</A>.
	return <<_EODESC;
Calculate your $state Driver's License number from your
information.
$describe_more
_EODESC
}






################################################################################
################################################################################
################################################################################
################################################################################

package main;



my(%CATEGORIES);
sub add_category {
	my($i) = @_;
	die if exists $CATEGORIES{$i->uid()};
	$CATEGORIES{$i->uid()} = $i;
}
add_category(UniqueID::DriversLicense::Wisconsin->new());
add_category(UniqueID::DriversLicense::WisconsinReverse->new());
add_category(UniqueID::Coding::Soundex->new());
add_category(UniqueID::DriversLicense::Illinois->new());
add_category(UniqueID::DriversLicense::IllinoisReverse->new());
add_category(UniqueID::DriversLicense::Florida->new());
add_category(UniqueID::DriversLicense::FloridaReverse->new());
add_category(UniqueID::DriversLicense::Washington->new());
add_category(UniqueID::DriversLicense::NewHampshire->new());
add_category(UniqueID::Coding::DLFirstMiddle->new());



main();
exit;


#===============================================================================
sub main
{
	print "Content-type: text/html\n\n";

	my($category) = param('type');
	if(not defined $category) {
		my($tmp) = $ENV{'PATH_INFO'};
		($category) = ($tmp =~ m|/*([^/]+)|) if defined $tmp;
	}

	if(not defined $category) {
		print get_header();
		print get_footer();
		return;
	}

	my($impl) = $CATEGORIES{$category};
	if(not defined $impl)
	{
		print get_header($category);
		print "error, bad category $category\n";
		print get_footer();
		return;
	}


	my(@params) = param();
	my %params;
	foreach my $p (@params)
	{
		$params{$p} = param($p);
	}
	$params{'type'} = $category;

	my($step) = param('step');
	if(not defined $step)
	{
		print get_header($category);
		print get_impl_form($impl, \%params, {});
		print get_footer();
		return;
	}

	print get_header($category);
	my($error_fields, $error_explain, $output) =
		$impl->process(%params);
	print "<H2>".$impl->display_name()." Output</H2>\n";
	print "<H3>Input</H3>\n";
	print describe_params($impl, %params);
	print "<H3>Output</H3>\n";
	print "$output \n" if defined $output;
	print "$error_explain\n" if defined $error_explain;
	print "<P><HR>\n";
	print get_impl_form($impl, \%params, $error_fields);
	print get_footer();
}

#===============================================================================
sub describe_params {
	my($impl, %params) = @_;
	my(@options) = $impl->options();
	my $ret = '';
	foreach my $option (@options) {
		my($label, $name, $type, @other) = @{$option};
		my $val = '';
		if(defined $name) {
			$val = $params{$name} || '';
		}
		$ret .= format_key_value($label, $val);
	}
	return $ret;
}

#===============================================================================
sub get_impl_form {
	my($impl, $params, $error_fields) = @_;
	my $ret = '';
	$ret .= '<H2>'.
		$impl->display_name().
		'</H2>'.
		$impl->describe().
		get_form_header().
		get_form_options($impl->uid(), [$impl->options()], $params, $error_fields).
		get_form_footer().
		'';

}

#===============================================================================
sub get_header
{
	my($this_type) = @_;
	$this_type = '' if not defined $this_type;
	my $ret = '';
	my $display_name = 'Select a category';
	if(defined $this_type and defined $CATEGORIES{$this_type}) {
		$display_name = $CATEGORIES{$this_type}->display_name();
	}
	$ret .= <<_EOHEADER;
<HTML>
<HEAD>
<TITLE>Unique ID: $display_name</TITLE>
</HEAD>
<BODY>
<H1>Unique ID</H1>
_EOHEADER
	$ret .= get_form_header();
	$ret .= qq(<SELECT NAME="type">\n);
	foreach my $key (sort { $CATEGORIES{$a}->display_name() cmp $CATEGORIES{$b}->display_name() } keys %CATEGORIES)
	{
		my $name = $CATEGORIES{$key}->display_name();
		my $selected = '';
		$selected = ' SELECTED' if $key eq $this_type;
		$ret .= qq(<OPTION VALUE="$key"$selected>$name</OPTION>\n);
	}
	$ret .= qq(</SELECT>\n);
	$ret .= get_form_footer('Change category');
	$ret .= "<HR>\n";
	return $ret;
}
#===============================================================================
sub get_form_header
{
	my($path) = path_to_script();
	return qq(<FORM ACTION="$path" METHOD=POST>\n);
}
#===============================================================================
sub get_form_footer
{
	my($label) = @_;
	$label ||= 'Submit';
	return qq(<INPUT TYPE="SUBMIT" VALUE="$label">\n</FORM>\n);
}
#===============================================================================
sub get_footer
{
	return <<END_FOOTER;
<hr>
<p>Results by $PROGRAM_NAME version $VERSION
<p>This software (and any results) is provided with ABSOLUTELY NO WARRANTY.
<a href="http://www.highprogrammer.com/alan/numbers/disclaimer.html">Further
disclaimer details</a>.
<p><a href="http://www.highprogrammer.com/alan/numbers/software.html">You can
get a copy of this software</a>.
</BODY>
</HTML>
END_FOOTER
}


#===============================================================================
sub get_form_options
{
	my($uid, $options, $params, $errors) = @_;
	my(%params) = %{$params};
	my(%errors) = %{$errors};
	my($ret) = '';
	$ret .= qq(<INPUT TYPE="HIDDEN" NAME="type" VALUE="$uid">);
	$ret .= qq(<INPUT TYPE="HIDDEN" NAME="step" VALUE="1">);
	$ret .= '<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0">'."\n";
	foreach my $option (@{$options}) {
		my($label, $name, $type, @other) = @{$option};
		my($indent) = ($label =~ /^( *)/);
		$indent =~ s/ /\&nbsp;\&nbsp;\&nbsp;/g;
		$label =~ s/^ */$indent/g;
		$ret .= '<TR><TD>'.format_label($label).'</TD><TD>';
		if(defined $name and defined $type) {
			my($value) = $params{$name} || '';
			if($type eq 'radio') {
				foreach my $entry (@{$other[0]}) {
					my $sel = ($entry eq $value) ? ' CHECKED' : '';
					$ret .= qq(<INPUT TYPE="RADIO" NAME="$name" VALUE="$entry"$sel> $entry<BR>);
				}
			} else {
				# hopefully $type eq 'text'
				my($length) = $other[0] || 10;
				$ret .= qq(<INPUT TYPE="TEXT" NAME="$name" VALUE= "$value" SIZE="$length">);
			}
		}
		$ret .= "<TD>";
		if(defined $errors{$name}) {
			$ret .= "Error: $errors{$name}";
		}
		$ret .= "</TD></TR>\n";
	}
	$ret .= "</TABLE>\n";
	return $ret;
}
