#! /usr/bin/perl -wT

# Unique ID
#
# Experimental implementation for algorithms as described
# on the Unique ID web site (http://www.highprogrammer.com/alan/numbers/)
#
# Copyright 2002, Alan De Smet.
#
# This software comes with NO WARRANTY of any sort.

use CGI qw(param);
use Text::Soundex;
use strict;

#===============================================================================
my(%DLFM_FIRST_MALE) = (
	20=>['Albert'], 40=>['Arthur'], 80=>['Bernard'], 120=>['Carl'],
	140=>['Charles'], 180=>['Donald'], 220=>['Edward'], 260=>['Frank'],
	300=>['George'], 340=>['Harold'], 360=>['Harry'], 380=>['Henry'],
	440=>['James'], 460=>['John'], 480=>['Joseph'], 560=>['Martin'],
	580=>['Marvin'], 600=>['Melvin'], 680=>['Paul'], 740=>['Richard'],
	760=>['Robert'], 820=>['Thomas'], 900=>['Walter'], 920=>['William'],
	);
my(%DLFM_FIRST_FEMALE) = (
	20=>['Alice'], 40=>['Ann', 'Anna', 'Anne', 'Annie'],
	80=>['Bette', 'Bettie', 'Betty'], 120=>['Catherine'],
	140=>['Clara'], 180=>['Dorothy'], 220=>['Elizabeth'],
	260=>['Florence'], 300=>['Grace'], 340=>['Harriet'],
	360=>['Hazel'], 380=>['Helen'], 440=>['Jane', 'Jayne'],
	460=>['Jean'], 480=>['Joan'], 580=>['Mary'], 600=>['Mildred'],
	680=>['Patricia'], 740=>['Ruby'], 760=>['Ruth'], 820=>['Thelma'],
	900=>['Wanda'], 920=>['Wilma'],
	);
my(%DLFM_FIRST_INIT) = (
	0 => 'A', 60 => 'B', 100 => 'C', 160 => 'D', 200 => 'E', 240 => 'F',
	280 => 'G', 320 => 'H', 400 => 'I', 420 => 'J', 500 => 'K', 520 => 'L',
	540 => 'M', 620 => 'N', 640 => 'O', 660 => 'P', 700 => 'Q', 720 => 'R',
	780 => 'S', 800 => 'T', 840 => 'U', 860 => 'V', 880 => 'W', 940 => 'X',
	960 => 'Y', 980 => 'Z',
	);
my(%DLFM_MIDDLE_INIT) = (
	1 => [qw(A)], 2 => [qw(B)], 3 => [qw(C)], 4 => [qw(D)],
	5 => [qw(E)], 6 => [qw(F)], 7 => [qw(G)], 8 => [qw(H)],
	9 => [qw(I)], 10 => [qw(J)], 11 => [qw(K)], 12 => [qw(L)],
	13 => [qw(M)], 14 => [qw(N O)], 15 => [qw(P Q)], 16 => [qw(R)],
	17 => [qw(S)], 18 => [qw(T U V)], 19 => [qw(W X Y Z)],
	);

#===============================================================================
sub english_list_join {
	my($word, @list) = @_;
	if(scalar @list == 0) {
		return '';
	}
	if(scalar @list == 1) {
		return $list[0];
	}
	if(scalar @list == 2) {
		return "$list[0] $word $list[1]";
	}
	my $tail = pop @list;
	return (join ', ', @list).", $word $tail";
}

#===============================================================================
sub dlfirstmiddle_middle_from_code {
	my($code) = @_;
	$code %= 20;
	if(not exists $DLFM_MIDDLE_INIT{$code}) {
		return '';
	}

	my(@answer) = @{$DLFM_MIDDLE_INIT{$code}};

	return english_list_join('or', @answer);
}

#===============================================================================
sub dlfirstmiddle_first_from_code {
	my($code, $gender) = @_;
	$code -= $code % 20;
	my(@female, @male);
	if(exists $DLFM_FIRST_FEMALE{$code}) {
		@female = @{$DLFM_FIRST_FEMALE{$code}};
	}
	if(exists $DLFM_FIRST_MALE{$code}) {
		@male = @{$DLFM_FIRST_MALE{$code}};
	}

	my(@probable, @improbable);
	if($gender =~ /^m/i) {
		@probable = @male;
		@improbable = @female;
	} elsif($gender =~ /^f/i) {
		@probable = @female;
		@improbable = @male;
	} else {
		@probable = (@male, @female);
	}

	if(not @probable and exists $DLFM_FIRST_INIT{$code}) {
		@probable = ($DLFM_FIRST_INIT{$code}.'.');
	}

	my $return = english_list_join('or', @probable);
	if(scalar @improbable) {
		$return .= ' (or possibly '.
			english_list_join('or', @improbable).')';
	}
	return $return;
}

#===============================================================================
sub soundex_database { '/home/chaos/public/soundex.data' }


#===============================================================================
sub soundex_similar_last_names
{
	my($Soundex) = @_;
	my($database) = main::soundex_database();
	open(INDEX,$database) or
		return "Name database is currently unavailable.  ".
		"Unable to display name guesses. Please try again later.".
		"($database  $!)"
		;
	main::look(*INDEX, $Soundex, 0, 0);
	my $line = <INDEX>;
	close(INDEX);
	($line) = ($line =~ /.+\t(.+)/);
	my(@names) = split(/, ?/, $line);
	foreach my $n (@names) {
		$n =~ s/(\w+)/\u\L$1/g;
	}
	return @names;
}

#===============================================================================
sub soundex_sound_guess
{
	my($Name) = @_;
	my($Return, @Parts, $This);
	@Parts = split(//,$Name);
	$Return = shift(@Parts).'e';
	while($This = shift(@Parts))
	{
		if   ($This == 1) { $Return .= 'be'; } #bfpv
		elsif($This == 2) { $Return .= 'se'; } #cgjkqsxz
		elsif($This == 3) { $Return .= 'te'; } #td
		elsif($This == 4) { $Return .= 'le'; } #l
		elsif($This == 5) { $Return .= 'me'; } #mn
		elsif($This == 6) { $Return .= 're'; } #r
	}
	return($Return);
}

#===============================================================================
sub describe_soundex
{
	my($Name) = @_;
	my($Return, @Parts, $This);

	@Parts = split(//,$Name);

	$Return = 'Starts with a '.shift(@Parts);
	while($This = shift(@Parts))
	{
		$Return .= ', followed by a ';
		if   ($This == 1) { $Return .= 'labial (B, F, P, or V)'; }
		elsif($This == 2) { $Return .= 'gutteral or sibilant (C, G, J, K, Q, S, X, or Z)'; }
		elsif($This == 3) { $Return .= 'dental (D or T)'; }
		elsif($This == 4) { $Return .= 'long liquid (L)'; }
		elsif($This == 5) { $Return .= 'nasal (M or N)'; }
		elsif($This == 6) { $Return .= 'short liquid (R)'; }
	}
	$Return .= '.';
	return($Return);
}

#===============================================================================
sub validate_options
{
	my($params, $options) = @_;
	my(%params) = %{$params};
	my(@options) = @{$options};
	my($error, %error) = ('');
	foreach my $option (@options) {
		my($name, $key) = @{$option};
		next if not defined $key or not length $key;
		my($value) = $params{$key};
		if(not defined $value or not length $value) {
			if(not defined $error{$key}) {
				$error{$key} = '';
			}
			$error{$key} .= "Please specify $name. ";
		}
	}
	return ($error, %error);
}

#===============================================================================
sub path_to_script {
	return $ENV{'SCRIPT_NAME'} || '';
}

#===============================================================================
sub format_label {
	my($label) = @_;
	my($indent) = ($label =~ /^( *)/);
	$indent =~ s/ /\&nbsp;\&nbsp;\&nbsp;/g;
	$label =~ s/^ */$indent/g;
	return qq(<STRONG>$label:\&nbsp;</STRONG>);
}

#===============================================================================
sub format_key_value {
	my($key, $value) = @_;
	return format_label($key).$value."<BR>\n";
}

#===============================================================================
# Usage: &look(*FILEHANDLE,$key,$dict,$fold)
# Sets file position in FILEHANDLE to be first line greater than or equal
# (stringwise) to $key.  Pass flags for dictionary order and case folding.
# taken from look.pl, part of perl distribution.

sub look {
	local(*FH, $_);
	my($key, $dict, $fold);
    (*FH,$key,$dict,$fold) = @_;
    my($max,$min,$mid);
    my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
       $blksize,$blocks) = stat(FH);
    $blksize = 8192 unless $blksize;
    $key =~ s/[^\w\s]//g if $dict;
    $key = lc $key if $fold;
    $max = int($size / $blksize);
    while ($max - $min > 1) {
	$mid = int(($max + $min) / 2);
	seek(FH,$mid * $blksize,0);
	$_ = <FH> if $mid;		# probably a partial line
	$_ = <FH>;
	chop;
	s/[^\w\s]//g if $dict;
	$_ = lc $_ if $fold;
	if ($_ lt $key) {
	    $min = $mid;
	}
	else {
	    $max = $mid;
	}
    }
    $min *= $blksize;
    seek(FH,$min,0);
    <FH> if $min;
    while (<FH>) {
	chop;
	s/[^\w\s]//g if $dict;
	$_ = lc $_ if $fold;
	last if $_ ge $key;
	$min = tell(FH);
    }
    seek(FH,$min,0);
    $min;
}


################################################################################
################################################################################
################################################################################
################################################################################





package UniqueID::Coding::DLFirstMiddle;

sub new {
	my $class = shift;
	$class = ref($class) if ref($class);

	bless my $self = {}, $class;

	return $self;
}

sub uid { 'c_firstmiddler' }
sub display_name { "First Name Middle Initial Coding Analyzer" }
sub describe {
	my($link) = main::path_to_script();
	return <<_EODESC;
Decode
<a href="http://www.highprogrammer.com/alan/numbers/dlfirstmiddle.html">name
encoding</a> used by many states for driver's licenses.
_EODESC
#'
}

sub options
{
	return(
		['Code', 'w', 'text', 3],
	);
}

sub process
{
	my($self) = shift;
	my(%params) = @_;
	my($code) = $params{'w'};
	my(%error_fields, $error_explain, $output);
	
	if(not defined $code or not length $code) {
		$error_fields{'w'} .= "Please specify an encoded name.";
	}

	if((defined $error_explain and length $error_explain) or
		scalar keys %error_fields){
		return(\%error_fields, $error_explain, $output);
	}

	my $middle_init = main::dlfirstmiddle_middle_from_code($code);
	my $first_name = main::dlfirstmiddle_first_from_code($code);

	$output = 
		main::format_key_value('First Name', $first_name).
		main::format_key_value('Middle Initial', $middle_init);

	return(\%error_fields, $error_explain, $output);
}


################################################################################
################################################################################
################################################################################
################################################################################





package UniqueID::Coding::Soundex;

sub new {
	my $class = shift;
	$class = ref($class) if ref($class);

	bless my $self = {}, $class;

	return $self;
}

sub uid { 'c_soundex' }
sub display_name { "Soundex Coding" }
sub describe {
	my($link) = main::path_to_script();
	return <<_EODESC;
Given an english word, determine the
<A HREF="http://www.highprogrammer.com/alan/numbers/soundex.html">soundex
code</A>.  Soundex codes are used in many places, including
<A HREF="http://www.highprogrammer.com/alan/numbers/dl_wi/">Wisconsin Driver's
License Numbers</A>.
_EODESC
#'
}

sub options
{
	return(
		["Word", 'w', 'text', 50],
	);
}

sub process
{
	my($self) = shift;
	my(%params) = @_;
	my($word) = $params{'w'};
	my(%error_fields, $error_explain, $output);
	
	if(not defined $word or not length $word) {
		$error_fields{'w'} .= "Please specify an english word.";
	}

	if((defined $error_explain and length $error_explain) or
		scalar keys %error_fields){
		return(\%error_fields, $error_explain, $output);
	}

	my $soundex = main::soundex($word);

	$output = main::format_key_value('Soundex', $soundex);

	return(\%error_fields, $error_explain, $output);
}


################################################################################
################################################################################
################################################################################
################################################################################





package UniqueID::DriversLicense::WisconsinReverse;

sub new {
	my $class = shift;
	$class = ref($class) if ref($class);

	bless my $self = {}, $class;

	return $self;
}

sub uid { 'dl_wir' }
sub display_name { "Wisconsin Driver's License Analyzer" }
sub describe {
	my($link) = main::path_to_script();
	return <<_EODESC;
Given a Wisconsin Driver's License number, determine it's owner's
identity.
<A HREF="http://www.highprogrammer.com/alan/numbers/dl_wi/">How it works</A>.
<A HREF="$link/dl_wi">Create a fictional number to test</A>.
_EODESC
#'
}

sub options
{
	return(
		["Wisconsin Driver's License Number", 'l', 'text', 17],
	);
}

sub process
{
	my($self) = shift;
	my(%params) = @_;
	my($lic) = $params{'l'};
	my(%error_fields, $error_explain, $output);
	

	my($last, $first_middle, $year_ten, $year_one, $day_month, $count) =
		($lic =~ /([A-Za-z]\d\d\d)-(\d\d\d)(\d)-(\d)(\d\d\d)-(..)/);
	if(not defined $day_month) {
		$error_fields{'l'} .=
		"Please specify a Wisconsin Driver's License number. It will look ".
		'like "S530-4615-0244-03".';
	}

	if((defined $error_explain and length $error_explain) or
		scalar keys %error_fields){
		return(\%error_fields, $error_explain, $output);
	}

	my($gender) = gender($day_month);
	my($first_name) = first_name($first_middle, $gender);
	my($middle_init) = middle_init($first_middle).'.';
	my($last_name_sound) = main::describe_soundex($last);
	my($last_name_sound_guess) = main::soundex_sound_guess($last);
	my(@similar_last_names) = main::soundex_similar_last_names($last);
	my($similar_last_names) = join(', ', @similar_last_names);
	my($month) = month_name($day_month);
	my($day) = day($day_month);
	my($year) = $year_ten.$year_one;

	$output =
		main::format_key_value('First Name', $first_name).
		main::format_key_value('Middle Initial', $middle_init).
		main::format_key_value('Last Name', $last_name_sound.
		" Perhaps it sounds like \"$last_name_sound_guess\"").
		main::format_key_value('Last Name Guesses', $similar_last_names).
		main::format_key_value('Gender', $gender).
		main::format_key_value('Date of Birth', "$month $day, '$year").
		main::format_key_value('Wild Guess', "$first_name $middle_init ".
			"$similar_last_names[0], $gender, born $month $day, 19$year").
		'';

	return(\%error_fields, $error_explain, $output);
}

sub day {
	my($input) = @_;
	$input %= 500;
	return($input % 40);
}

sub month_num {
	my($input) = @_;
	$input %= 500;
	return(($input - day($input)) / 40 + 1);
}

sub month_name {
	my($input) = @_;
	my(@MONTHS) = ( 'January', 'February', 'March', 'April', 'May', 'June',
		'July', 'August', 'September', 'October', 'November', 'December' );
	return @MONTHS[month_num($input)-1];
}

sub gender {
	my($input) = @_;
	if($input > 500) { return 'female'; }
	return 'male';
}

sub middle_init
{
	my($input) = @_;
	return main::dlfirstmiddle_middle_from_code($input);
}


sub first_name
{
	my($Input, $Gender) = @_;
	return main::dlfirstmiddle_first_from_code($Input, $Gender);
}




################################################################################
################################################################################
################################################################################
################################################################################





package UniqueID::DriversLicense::Wisconsin;

sub new {
	my $class = shift;
	$class = ref($class) if ref($class);

	bless my $self = {}, $class;

	return $self;
}

sub uid { 'dl_wi' }
sub display_name { "Wisconsin Driver's License Calculator" }
sub describe {
	my($link) = main::path_to_script();
	return <<_EODESC;
Calculate your Wisconsin Driver's License number from your
information.
<A HREF="http://www.highprogrammer.com/alan/numbers/dl_wi/">How it works</A>.
<A HREF="$link/dl_wir">Reverse analyze an exististing number</A>.
_EODESC
#'
}

sub options
{
	return(
		['Last Name', 'last', 'text', 40],
		['First Name', 'first', 'text', 40],
		['Middle Initial', 'middle', 'text', 1],
		['Gender', 'gender', 'radio', ['M', 'F'] ],
		['Date of Birth'],
		[' Year', 'y', 'text', 4],
		[' Month', 'm', 'text', 2],
		[' Day', 'd', 'text', 2],
	);
}

sub process
{
	my($self) = shift;
	my(%params) = @_;
	my($last) = $params{'last'};
	my($first) = $params{'first'};
	my($middle) = $params{'middle'};
	my($gender) = uc($params{'gender'});
	my($yy) = $params{'y'};
	my($mm) = $params{'m'};
	my($dd) = $params{'d'};
	my(%error_fields, $error_explain, $output);

	($error_explain, %error_fields) =
		main::validate_options(\%params, [$self->options()]);

	$yy -= 1900 if $yy >= 1900 and $yy < 2000;
	$yy -= 2000 if $yy >= 2000 and $yy < 2100;

	if($yy > 99 or $yy < 0) {
		$error_fields{'y'} .= 'Please specify year of birth as a one or '.
			'two digit number. '.
			'For example, for 1975 specify "75", for 2006 specify "6".';
	}
	if($mm > 12 or $mm < 1) {
		$error_fields{'m'} .= 'Please specify month of birth as a '.
			'number from 1 to 12. '.
			'For example, for January specify "1", for December specify "12".';
	}
	if($dd > 31 or $dd < 1) {
		$error_fields{'d'} .= 'Please specify day of birth as a '.
			'number from 1 to 31.';
	}
	if($gender ne 'M' and $gender ne 'F') {
		$error_fields{'gender'} .= 'Please specify gender.';
	}
	
	if((defined $error_explain and length $error_explain) or
		scalar keys %error_fields){
		return(\%error_fields, $error_explain, $output);
	}

	$middle = substr $middle, 0, 1;
	my($YearTens, $YearOnes) = split(//,sprintf("%02d",$yy));

	my $dl = main::soundex($last).'-'.
		first_name_middle_init($first, $middle).
		$YearTens.'-'.$YearOnes.
		month_day_gender($mm, $dd, $gender).'-??';
	
	$output = main::format_key_value("Driver's License Number", $dl).
	"The last two digits cannot be determined.  They represent the ".
	"number of people who have the exact same license number as you ".
	"(excepting the last two digits), when you got your license.";
	


	return(\%error_fields, $error_explain, $output);
}

sub month_day_gender
{
	my($Month, $Day, $Gender) = @_;
	my($DateNo);
	$Gender = uc($Gender);

	$DateNo = ($Month - 1) * 40 + $Day;
	if($Gender eq 'F') { $DateNo += 500; }

	$DateNo = sprintf("%03d",$DateNo);

	return($DateNo);
}


sub first_name_middle_init
{
	my($FN, $MiddleInit) = @_;
	my($NameNum, %FirstNameLookup, %FirstInitLookup, %MiddleInitLookup);
	my($Return);

	$FN = uc($FN);
	$MiddleInit = uc($MiddleInit);

	%FirstNameLookup =
	(
		'ALBERT'	=> 20, 'ALICE'		=> 20,
		'ANN'		=> 40, 'ANNE'		=> 40, 'ANNA'		=> 40,
		'ANNIE'		=> 40, 'ARTHUR'	=> 40,
		'BERNARD'	=> 80, 'BETTY'		=> 80, 'BETTE'		=> 80,
		'BETTIE'	=> 80,
		'CARL'		=> 120, 'CATHERINE'	=> 120,
		'CHARLES'	=> 140, 'CLARA'		=> 140,
		'DONALD'	=> 180, 'DOROTHY'	=> 180,
		'EDWARD'	=> 220, 'ELIZABETH'	=> 220,
		'FLORENCE'	=> 260, 'FRANK'		=> 260,
		'GEORGE'	=> 300, 'GRACE'		=> 300,
		'HAROLD'	=> 340, 'HARRIET'	=> 340,
		'HARRY'		=> 360, 'HAZEL'		=> 360,
		'HELEN'		=> 380, 'HENRY'		=> 380,
		'JAMES'		=> 440, 'JANE'		=> 440, 'JAYNE'		=> 440,
		'JEAN'		=> 460, 'JOHN'		=> 460,
		'JOAN'		=> 480, 'JOSEPH'	=> 480,
		'MARGARET'	=> 560, 'MARTIN'	=> 560,
		'MARVIN'	=> 580, 'MARY'		=> 580,
		'MELVIN'	=> 600, 'MILDRED'	=> 600,
		'PATRICIA'	=> 680, 'PAUL'		=> 680,
		'RICHARD'	=> 740, 'RUBY'		=> 740,
		'ROBERT'	=> 760, 'RUTH'		=> 760,
		'THELMA'	=> 820, 'THOMAS'	=> 820,
		'WALTER'	=> 900, 'WANDA'		=> 900,
		'WILLIAM'	=> 920, 'WILMA'		=> 920,
	);

	%FirstInitLookup =
	(
		'A' =>   0, 'B' =>  60, 'C' => 100, 'D' => 160, 'E' => 200, 'F' => 240,
		'G' => 280, 'H' => 320, 'I' => 400, 'J' => 420, 'K' => 500, 'L' => 520,
		'M' => 540, 'N' => 620, 'O' => 640, 'P' => 660, 'Q' => 700, 'R' => 720,
		'S' => 780, 'T' => 800, 'U' => 840, 'V' => 860, 'W' => 880, 'X' => 940,
		'Y' => 960, 'Z' => 980,
	);

	%MiddleInitLookup =
	(
		'A' =>  1, 'B' =>  2, 'C' =>  3, 'D' =>  4, 'E' =>  5, 'F' =>  6,
		'G' =>  7, 'H' =>  8, 'I' =>  9, 'J' => 10, 'K' => 11, 'L' => 12,
		'M' => 13, 'N' => 14, 'O' => 14, 'P' => 15, 'Q' => 15, 'R' => 16,
		'S' => 17, 'T' => 18, 'U' => 18, 'V' => 18, 'W' => 19, 'X' => 19,
		'Y' => 19, 'Z' => 19,
	);

	if(defined($FirstNameLookup{$FN}))
		{ $NameNum = $FirstNameLookup{$FN}; }
	elsif(defined($FirstInitLookup{(split(//,$FN))[0]}))
		{ $NameNum = $FirstInitLookup{(split(//,$FN))[0]}; }
	else
		{ return('BAD'); }

	if(defined($MiddleInitLookup{$MiddleInit}))
		{ $NameNum += $MiddleInitLookup{$MiddleInit}; }
	else
		{ return('BAD'); }

	$Return = sprintf("%03d",$NameNum);

	return($Return);
}






################################################################################
################################################################################
################################################################################
################################################################################





package UniqueID::DriversLicense::Illinois;

sub new {
	my $class = shift;
	$class = ref($class) if ref($class);

	bless my $self = {}, $class;

	return $self;
}

sub uid { 'dl_il' }
sub display_name { "Illinois Driver's License Calculator" }
sub describe {
	my($link) = main::path_to_script();
	return <<_EODESC;
Calculate your Illinois Driver's License number from your
information.
<STRONG>This is a work in progress and is not yet complete.</STRONG>
<A HREF="http://www.highprogrammer.com/alan/numbers/dl_il/">How it works</A>.
<A HREF="$link/dl_ilr">Reverse analyze an exististing number</A>.
_EODESC
#'
}

sub options
{
	return(
		['Last Name', 'last', 'text', 40],
		#['First Name', 'first', 'text', 40],
		#['Middle Initial', 'middle', 'text', 1],
		['Gender', 'gender', 'radio', ['M', 'F'] ],
		['Date of Birth'],
		[' Year', 'y', 'text', 4],
		[' Month', 'm', 'text', 2],
		[' Day', 'd', 'text', 2],
	);
}

sub process
{
	my($self) = shift;
	my(%params) = @_;
	my($last) = $params{'last'};
	#my($first) = $params{'first'};
	#my($middle) = $params{'middle'};
	my($gender) = uc($params{'gender'});
	my($yy) = $params{'y'};
	my($mm) = $params{'m'};
	my($dd) = $params{'d'};
	my(%error_fields, $error_explain, $output);

	($error_explain, %error_fields) =
		main::validate_options(\%params, [$self->options()]);

	$yy -= 1900 if $yy >= 1900 and $yy < 2000;
	$yy -= 2000 if $yy >= 2000 and $yy < 2100;

	if($yy > 99 or $yy < 0) {
		$error_fields{'y'} .= 'Please specify year of birth as a one or '.
			'two digit number. '.
			'For example, for 1975 specify "75", for 2006 specify "6".';
	}
	if($mm > 12 or $mm < 1) {
		$error_fields{'m'} .= 'Please specify month of birth as a '.
			'number from 1 to 12. '.
			'For example, for January specify "1", for December specify "12".';
	}
	if($dd > 31 or $dd < 1) {
		$error_fields{'d'} .= 'Please specify day of birth as a '.
			'number from 1 to 31.';
	}
	if($gender ne 'M' and $gender ne 'F') {
		$error_fields{'gender'} .= 'Please specify gender.';
	}
	
	if((defined $error_explain and length $error_explain) or
		scalar keys %error_fields){
		return(\%error_fields, $error_explain, $output);
	}

	#$middle = substr $middle, 0, 1;
	my($YearTens, $YearOnes) = split(//,sprintf("%02d",$yy));

	my $dl = main::soundex($last).'-'.
		'???'.
		$YearTens.'-'.$YearOnes.
		month_day_gender($mm, $dd, $gender).'-??';
	
	$output = main::format_key_value("Driver's License Number", $dl).
	"I don't yet know how the fourth through sixth digits are calculated. ".
	"The last two digits cannot be determined.  They represent the ".
	"number of people who have the exact same license number as you ".
	"(excepting the last two digits), when you got your license.";
	


	return(\%error_fields, $error_explain, $output);
}

sub month_day_gender
{
	my($Month, $Day, $Gender) = @_;
	my($DateNo);
	$Gender = uc($Gender);

	$DateNo = ($Month - 1) * 40 + $Day;
	if($Gender eq 'F') { $DateNo += 500; }

	$DateNo = sprintf("%03d",$DateNo);

	return($DateNo);
}



################################################################################
################################################################################
################################################################################
################################################################################





package UniqueID::DriversLicense::IllinoisReverse;

sub new {
	my $class = shift;
	$class = ref($class) if ref($class);

	bless my $self = {}, $class;

	return $self;
}

sub uid { 'dl_ilr' }
sub display_name { "Illinois Driver's License Analyzer" }
sub describe {
	my($link) = main::path_to_script();
	return <<_EODESC;
Given a Illinois Driver's License number, determine it's owner's
identity.
<STRONG>This is a work in progress and is not yet complete.</STRONG>
<A HREF="http://www.highprogrammer.com/alan/numbers/dl_wi/">How it works</A>.
<A HREF="$link/dl_il">Create a fictional number to test</A>.
_EODESC
#'
}

sub options
{
	return(
		["Illinois Driver's License Number", 'l', 'text', 17],
	);
}

sub process
{
	my($self) = shift;
	my(%params) = @_;
	my($lic) = $params{'l'};
	my(%error_fields, $error_explain, $output);
	

	my($last, $first_middle, $year_ten, $year_one, $day_month, $count) =
		($lic =~ /([A-Za-z]\d\d\d)-(\d\d\d)(\d)-(\d)(\d\d\d)-(..)/);
	if(not defined $day_month) {
		$error_fields{'l'} .=
		"Please specify an Illinois Driver's License number. It will look ".
		'like "S530-4615-0244-03".';
	}

	if((defined $error_explain and length $error_explain) or
		scalar keys %error_fields){
		return(\%error_fields, $error_explain, $output);
	}

	my($gender) = gender($day_month);
	my($first_name) = first_name($first_middle, $gender);
	my($middle_init) = middle_init($first_middle).'.';
	my($last_name_sound) = main::describe_soundex($last);
	my($last_name_sound_guess) = main::soundex_sound_guess($last);
	my(@similar_last_names) = main::soundex_similar_last_names($last);
	my($similar_last_names) = join(', ', @similar_last_names);
	my($month) = month_name($day_month);
	my($day) = day($day_month);
	my($year) = $year_ten.$year_one;

	$output =
		main::format_key_value('First Name', $first_name).
		main::format_key_value('Middle Initial', $middle_init).
		main::format_key_value('Last Name', $last_name_sound.
		" Perhaps it sounds like \"$last_name_sound_guess\"").
		main::format_key_value('Last Name Guesses', $similar_last_names).
		main::format_key_value('Gender', $gender).
		main::format_key_value('Date of Birth', "$month $day, '$year").
		main::format_key_value('Wild Guess', "$first_name $middle_init ".
			"$similar_last_names[0], $gender, born $month $day, 19$year").
		'';

	return(\%error_fields, $error_explain, $output);
}

sub day {
	my($input) = @_;
	$input %= 500;
	return($input % 40);
}

sub month_num {
	my($input) = @_;
	$input %= 500;
	return(($input - day($input)) / 40 + 1);
}

sub month_name {
	my($input) = @_;
	my(@MONTHS) = ( 'January', 'February', 'March', 'April', 'May', 'June',
		'July', 'August', 'September', 'October', 'November', 'December' );
	return @MONTHS[month_num($input)-1];
}

sub gender {
	return 'Unknown (work in progress)';
	#my($input) = @_;
	#if($input > 500) { return 'female'; }
	#return 'male';
}

sub middle_init
{
	return 'Unknown (work in progress)';
	my($input) = @_;
	$input %= 20;
	my(%MIDDLE_INIT) = (
		1 => 'A', 2 => 'B', 3 => 'C', 4 => 'D', 5 => 'E', 6 => 'F', 7 => 'G',
		8 => 'H', 9 => 'I', 10 => 'J', 11 => 'K', 12 => 'L', 13 => 'M',
		14 => 'N or O', 15 => 'P or Q', 16 => 'R', 17 => 'S',
		18 => 'T, U, or V', 19 => 'W, X, Y, or Z',
	);

	return($MIDDLE_INIT{$input});
}


sub first_name
{
	return 'Unknown (work in progress)';
	my($Input, $Gender) = @_;
	my(%Male, %Female, %FirstInit);
	my($Name);
	%Male = (
		120=>'Carl', 140=>'Charles', 180=>'Donald', 20=>'Albert',
		220=>'Edward', 260=>'Frank', 300=>'George', 340=>'Harold',
		360=>'Harry', 380=>'Henry', 40=>'Arthur', 440=>'James',
		460=>'John', 480=>'Joseph', 560=>'Martin', 580=>'Marvin',
		600=>'Melvin', 680=>'Paul', 740=>'Richard', 760=>'Robert',
		80=>'Bernard', 820=>'Thomas', 900=>'Walter', 920=>'William',
	);
	%Female = (
		120=>'Catherine', 140=>'Clara', 180=>'Dorothy', 20=>'Alice',
		220=>'Elizabeth', 260=>'Florence', 300=>'Grace', 340=>'Harriet',
		360=>'Hazel', 380=>'Helen', 40=>'Ann, Anna, Anne, Annie',
		440=>'Jane, Jayne', 460=>'Jean', 480=>'Joan', 580=>'Mary',
		600=>'Mildred', 680=>'Patricia', 740=>'Ruby', 760=>'Ruth',
		80=>'Bette, Bettie, Betty', 820=>'Thelma', 900=>'Wanda', 920=>'Wilma',
	);
	%FirstInit = (
		0 => 'A', 60 => 'B', 100 => 'C', 160 => 'D', 200 => 'E', 240 => 'F',
		280 => 'G', 320 => 'H', 400 => 'I', 420 => 'J', 500 => 'K', 520 => 'L',
		540 => 'M', 620 => 'N', 640 => 'O', 660 => 'P', 700 => 'Q', 720 => 'R',
		780 => 'S', 800 => 'T', 840 => 'U', 860 => 'V', 880 => 'W', 940 => 'X',
		960 => 'Y', 980 => 'Z',
	);

	$Input -= $Input%20;
 	if(defined($Male{$Input}))
 	{
		if($Gender =~ /f/i)	{ $Name = $Female{$Input}; }
		else				{ $Name = $Male{$Input}; }
	}
 	else
 		{ $Name = $FirstInit{$Input}; }
	return($Name);
}











################################################################################
################################################################################
################################################################################
################################################################################




package main;

my(%CATEGORIES);
sub add_category {
	my($i) = @_;
	die if exists $CATEGORIES{$i->uid()};
	$CATEGORIES{$i->uid()} = $i;
}
add_category(UniqueID::DriversLicense::Wisconsin->new());
add_category(UniqueID::DriversLicense::WisconsinReverse->new());
add_category(UniqueID::Coding::Soundex->new());
add_category(UniqueID::DriversLicense::Illinois->new());
add_category(UniqueID::DriversLicense::IllinoisReverse->new());
add_category(UniqueID::Coding::DLFirstMiddle->new());



main();
exit;


#===============================================================================
sub main
{
	print "Content-type: text/html\n\n";

	my($category) = param('type');
	if(not defined $category) {
		my($tmp) = $ENV{'PATH_INFO'};
		($category) = ($tmp =~ m|/*([^/]+)|) if defined $tmp;
	}

	if(not defined $category) {
		print get_header();
		print get_footer();
		return;
	}

	my($impl) = $CATEGORIES{$category};
	if(not defined $impl)
	{
		print get_header($category);
		print "error, bad category $category\n";
		print get_footer();
		return;
	}


	my(@params) = param();
	my %params;
	foreach my $p (@params)
	{
		$params{$p} = param($p);
	}
	$params{'type'} = $category;

	my($step) = param('step');
	if(not defined $step)
	{
		print get_header($category);
		print get_impl_form($impl, \%params, {});
		print get_footer();
		return;
	}

	print get_header($category);
	my($error_fields, $error_explain, $output) =
		$impl->process(%params);
	print "<H2>".$impl->display_name()." Output</H2>\n";
	print "<H3>Input</H3>\n";
	print describe_params($impl, %params);
	print "<H3>Output</H3>\n";
	print "$output \n" if defined $output;
	print "$error_explain\n" if defined $error_explain;
	print "<P><HR>\n";
	print get_impl_form($impl, \%params, $error_fields);
	print get_footer();
}

#===============================================================================
sub describe_params {
	my($impl, %params) = @_;
	my(@options) = $impl->options();
	my $ret = '';
	foreach my $option (@options) {
		my($label, $name, $type, @other) = @{$option};
		my $val = $params{$name} || '';
		$ret .= format_key_value($label, $val);
	}
	return $ret;
}

#===============================================================================
sub get_impl_form {
	my($impl, $params, $error_fields) = @_;
	my $ret = '';
	$ret .= '<H2>'.
		$impl->display_name().
		'</H2>'.
		$impl->describe().
		get_form_header().
		get_form_options($impl->uid(), [$impl->options()], $params, $error_fields).
		get_form_footer().
		'';

}

#===============================================================================
sub get_header
{
	my($this_type) = @_;
	$this_type = '' if not defined $this_type;
	my $ret = '';
	$ret .= <<_EOHEADER;
<HTML>
<HEAD>
<TITLE>Unique ID</TITLE>
</HEAD>
<BODY>
<H1>Unique ID</H1>
_EOHEADER
	$ret .= get_form_header();
	$ret .= qq(<SELECT NAME="type">\n);
	foreach my $key (sort keys %CATEGORIES)
	{
		my $name = $CATEGORIES{$key}->display_name();
		my $selected = '';
		$selected = ' SELECTED' if $key eq $this_type;
		$ret .= qq(<OPTION VALUE="$key"$selected>$name</OPTION>\n);
	}
	$ret .= qq(</SELECT>\n);
	$ret .= get_form_footer('Change category');
	$ret .= "<HR>\n";
	return $ret;
}
#===============================================================================
sub get_form_header
{
	my($path) = path_to_script();
	return qq(<FORM ACTION="$path" METHOD=POST>\n);
}
#===============================================================================
sub get_form_footer
{
	my($label) = @_;
	$label ||= 'Submit';
	return qq(<INPUT TYPE="SUBMIT" VALUE="$label">\n</FORM>\n);
}
#===============================================================================
sub get_footer
{
	return "</BODY>\n</HTML>\n";
}


#===============================================================================
sub get_form_options
{
	my($uid, $options, $params, $errors) = @_;
	my(%params) = %{$params};
	my(%errors) = %{$errors};
	my($ret) = '';
	$ret .= qq(<INPUT TYPE="HIDDEN" NAME="type" VALUE="$uid">);
	$ret .= qq(<INPUT TYPE="HIDDEN" NAME="step" VALUE="1">);
	$ret .= '<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0">'."\n";
	foreach my $option (@{$options}) {
		my($label, $name, $type, @other) = @{$option};
		my($indent) = ($label =~ /^( *)/);
		$indent =~ s/ /\&nbsp;\&nbsp;\&nbsp;/g;
		$label =~ s/^ */$indent/g;
		$ret .= '<TR><TD>'.format_label($label).'</TD><TD>';
		if(defined $name and defined $type) {
			my($value) = $params{$name} || '';
			if($type eq 'radio') {
				foreach my $entry (@{$other[0]}) {
					my $sel = ($entry eq $value) ? ' CHECKED' : '';
					$ret .= qq(<INPUT TYPE="RADIO" NAME="$name" VALUE="$entry"$sel> $entry<BR>);
				}
			} else {
				# hopefully $type eq 'text'
				my($length) = $other[0] || 10;
				$ret .= qq(<INPUT TYPE="TEXT" NAME="$name" VALUE= "$value" SIZE="$length">);
			}
		}
		$ret .= "<TD>";
		if(defined $errors{$name}) {
			$ret .= "Error: $errors{$name}";
		}
		$ret .= "</TD></TR>\n";
	}
	$ret .= "</TABLE>\n";
	return $ret;
}
